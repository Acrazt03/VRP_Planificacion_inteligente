# -*- coding: utf-8 -*-
"""Proyecto VRP  fase 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15i7cyxoHYiI-05dFA0nvi1rUSZP7yGtG
"""

!pip install osmium
!pip install osmnx
!pip install follium

import numpy as np
import random
import matplotlib.pyplot as plt

num_cities = 10

def distance(city1, city2):
    return np.sqrt((city1[0] - city2[0])**2 + (city1[1] - city2[1])**2)

def mutation(individual, mutation_rate):
    mutated_individual = individual.copy()
    for i in range(len(mutated_individual)):
        if np.random.random() < mutation_rate:
            swap_index = np.random.randint(0, len(mutated_individual))
            mutated_individual[i], mutated_individual[swap_index] = mutated_individual[swap_index], mutated_individual[i]
    return mutated_individual

def generate_cities(num_cities):
    return np.random.randint(0, 100, size=(num_cities, 2))

cities = generate_cities(num_cities)

#Creamos la información de time window para cada ciudad
time_windows = np.random.randint(0, 100, size=(num_cities, 2))
time_windows.sort(axis=1)

def fitness(solution, cities, time_windows, velocidad, epsilon=1e-8):
    total_distance = 0
    total_penalty = 0
    current_time = 0

    for i in range(len(solution) - 1):
        city1 = cities[solution[i]]
        city2 = cities[solution[i + 1]]
        time_window1 = time_windows[solution[i]]
        time_window2 = time_windows[solution[i + 1]]

        distance_travelled = distance(city1, city2)
        total_distance += distance_travelled

        # Aqui tenemos restricción de tiempo
        current_time += distance_travelled / velocidad
        if current_time < time_window2[0]:
            total_penalty += time_window2[0] - current_time
            current_time = time_window2[0]
        elif current_time > time_window2[1]:
            total_penalty += current_time - time_window2[1]

    # Añadimos la distancia al depósito al final
    total_distance += distance(cities[solution[-1]], cities[solution[0]])

    # Aqui esta dividiendo la ponderación entre la distancia total y la penalización por restricción de tiempo
    # Para evaluar que tan buena es su solucion y tambien para convertir el problema en uno de maximización
    return 1 / (total_distance + total_penalty + epsilon)

def create_initial_population(population_size, num_cities):
    population = []
    for _ in range(population_size):
        individual = np.random.permutation(num_cities)
        population.append(individual)
    return np.array(population)

class CrossoverDeHijos:
    def __init__(self, parent1, parent2):
        self.parent1 = parent1
        self.parent2 = parent2

    def mx(self):
        size = len(self.parent1)
        child = [-1] * size
        cx1, cx2 = sorted(random.sample(range(size), 2))

        for i in range(cx1, cx2 + 1):
            child[i] = self.parent1[i]

        for i in range(size):
            if child[i] == -1:
                idx = i
                while self.parent2[idx] in child:
                    idx = np.where(self.parent1 == self.parent2[idx])[0][0]
                child[i] = self.parent2[idx]

        return np.array(child)



parent1 = np.array([2, 3, 4, 5])
parent2 = np.array([4, 3, 2, 1])

crossover_de_hijos = CrossoverDeHijos(parent1, parent2)
hijo = crossover_de_hijos.mx()

def selection(population, elite_size, cities, time_windows, velocidad):
      fitness_scores = [fitness(solution, cities, time_windows, velocidad) for solution in population]
      elite_indices = np.argsort(fitness_scores)[-elite_size:]
      elite_population = population[elite_indices]
      return elite_population

class AlgoritmoGenetico:
    def __init__(self, cities, population_size, elite_size, mutation_rate, num_generations, velocidad):
        self.cities = cities
        self.population_size = population_size
        self.elite_size = elite_size
        self.mutation_rate = mutation_rate
        self.num_generations = num_generations
        self.velocidad = velocidad

    def genetic_algorithm_TSP(self):
        population = create_initial_population(self.population_size, len(self.cities))

        best_fitnesses = []
        for generation in range(self.num_generations):
            elite_population = selection(population, self.elite_size, self.cities, time_windows, self.velocidad)

            new_generation = []
            new_generation += list(elite_population)
            for i in range(self.population_size - self.elite_size):
                parent_indices = np.random.choice(elite_population.shape[0], 2, replace=False)
                parent1, parent2 = elite_population[parent_indices]
                crossover = CrossoverDeHijos(parent1, parent2)
                child = crossover.mx()  # Solo se produce un hijo
                child = mutation(child, self.mutation_rate)
                new_generation.append(child)

            population = np.array(new_generation)

            best_fitness = max([fitness(solution, self.cities, time_windows, self.velocidad) for solution in population])
            best_fitnesses.append(best_fitness)
            print("Generation:", generation, "Best fitness:", best_fitness)

        best_solution_index = np.argmax([fitness(solution, self.cities, time_windows, self.velocidad) for solution in population])
        best_solution = population[best_solution_index]

        return best_solution, 1 / best_fitness, best_fitnesses

velocidad = 100  # kilometros/hora
population_size = 10
elite_size = 4
mutation_rate = 0.1
num_generations = 20

algoritmo_genetico = AlgoritmoGenetico(cities, population_size, elite_size, mutation_rate, num_generations, velocidad)
best_solution, best_distance, best_fitnesses = algoritmo_genetico.genetic_algorithm_TSP()

print("Mejor solución:", best_solution)
print("Mejor distancia:", best_distance)

mejor_tiempo = best_distance
horas = int(mejor_tiempo // 3600)
minutos = int((mejor_tiempo % 3600) // 60)
segundos = int(mejor_tiempo % 60)

print(f"Tiempo que se tardó por recorrer todas las ciudades: {horas}h {minutos}m {segundos}s")

plt.plot(best_fitnesses)
plt.title("Evolución de la mejor aptitud")
plt.xlabel("Generación")
plt.ylabel("Mejor aptitud")  # El fitness
plt.show()